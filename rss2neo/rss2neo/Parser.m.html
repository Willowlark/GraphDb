<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>rss2neo.Parser API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#rss2neo.Parser.DEBUG">DEBUG</a></li>
    <li class="mono"><a href="#rss2neo.Parser.blue">blue</a></li>
    <li class="mono"><a href="#rss2neo.Parser.green">green</a></li>
    <li class="mono"><a href="#rss2neo.Parser.red">red</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#rss2neo.Parser.get_structured_topic">get_structured_topic</a></li>
    <li class="mono"><a href="#rss2neo.Parser.get_unstructured_topic">get_unstructured_topic</a></li>
    <li class="mono"><a href="#rss2neo.Parser.is_structured">is_structured</a></li>
    <li class="mono"><a href="#rss2neo.Parser.main">main</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#rss2neo.Parser.Topic_Candidate">Topic_Candidate</a></span>
        
          
  <ul>
    <li class="mono"><a href="#rss2neo.Parser.Topic_Candidate.__init__">__init__</a></li>
    <li class="mono"><a href="#rss2neo.Parser.Topic_Candidate.append_after">append_after</a></li>
    <li class="mono"><a href="#rss2neo.Parser.Topic_Candidate.keywordify">keywordify</a></li>
    <li class="mono"><a href="#rss2neo.Parser.Topic_Candidate.update_node">update_node</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">rss2neo.Parser</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser" class="source">
    <pre><code>from __future__ import division

import os
import unicodedata
import sys
import validators
import nltk
import json
import timeit
from functools import wraps
from collections import defaultdict
from markup_parser import markup_parser
from colors import red, green, blue

DEBUG = False

"""
This file stores the static methods to interpret topic candidates from zero or more bodies of text.
The work that accomplishes this is in the method parse_topics
Structured_topic returns the structured topic instances form the body of the text in the rss feed summary.
is_structured returns a true if input data is structured, else false.
"""

class Topic_Candidate(object):
    """
    `Author`: Bill Clark
    A class created by the Parser to represent a Topic object in the graph, in relation
    to the given record. The metadata then, is strictly tied to the record used when
    creating the candidate.
    """

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return str(self.title)

    def __init__(self, title, strength=None, label=None, after=None, before=None, suffix=None, prefix=None, depth=None):
        self.title = title
        self.strength = strength
        self.label = label
        self.after = after
        self.before = before
        self.depth = depth
        self.suffix = suffix
        self.prefix = prefix

    def keywordify(self):
        return {'name': self.title, 'strength': self.strength}

    def update_node(self, node):
        node['strength'] = self.strength
        return node

    def __eq__(self, other):
        return self.title == other.title

    def __ne__(self, other):
        return self.title != other.title

    def __hash__(self):
        return hash(self.title)

    def append_after(self, word):
        self.after.append(word)

def get_structured_topic(extracted):
    """
    `Author` Bob S.

    used by external modules to gather the structured topics of the summary of the feed json
    make_set is used to specify whether a set of unique topic candidate instances is formed from the result of the call to _strucutred_topic

    `extracted` the json object of the feed being examined
    `return` the result of the structured topic investigation.
    """
    body_of_text = extracted['summary']
    return _structured_topic(body_of_text)

def get_unstructured_topic(extracted, keys=('id', 'title', 'summary'), make_set=True):
    """
     `Author` Bob S.

    used by external modules to gather the unstructured topics of the summary of the feed json

    `extracted` the json object of the feed being examined
    `keys` the optional list of args that are the keys of the associative dictionary extracted to have topics extracted
    `make_set` optional argument for creating set of unique instances on return
    `debug` optional argument for printing state of topic candidates before return
    `return` the set of the unique topic candidate instances to be inserted by RssGrapher
    """
    ret = []
    for key in keys:
            ret.extend(_parse_topics(extracted[key]))
    return set(ret) if make_set else ret

def _reconstruct(listing):
    """
    `Author` Bob S.

    reconstruct the context of all topics from return listing alone.
    Requisite: the listing must be a list of topics already ordered by the order that they appear in the body of text where they were found

    `listing` the list of ORDERED topic candidate instances being iterated
    """

    # print topics of the NP persuasion
    for topic in sorted(listing, key = lambda k: k.depth): # sort by depth into the doc
        print green(repr(topic))
        for var in vars(topic):
            print '\t', var, ":", getattr(topic, var)
        print '\t', ' '.join(topic.before[-10:]), red(repr(topic)), ' '.join(topic.after[:10])

    ret = ''
    first_topic = listing[0]
    topic = first_topic
    ret += blue(' '.join(topic.before))
    while topic is not None:
        ret += ' ' + red(str(topic)) + ' ' + blue(' '.join(topic.after))
        topic = topic.suffix
    ret += '\n'
    print ret

def _structured_topic(body_of_text, try_markup=False):
    """
    `Author` Bob S.

    This method will render the list of structured topics form the predisposed format of data, a JSON string.

    `body_of_text` the string to be parsed from the rss feed
    `try_markup` the optional argument to attempt to markup the body of text as json for manipulation
    `return` ret, the list of structured topics from the body of text
    """
    if try_markup and not is_structured(body_of_text):
        mkup = markup_parser()
        return mkup.to_json(body_of_text)
    return json.loads(body_of_text)

def _parse_topics(body_of_text):
    """
    `Author` Bob S.

    Used for parsing topic candidates, form conjunctive crucial words, that are of the Noun persuasion.
    The instances of topic candidate that are returned will be used in the database as units for relation creation

    `body_of_text` - the raw body of text to be processed
    `debug` optional argument for printing state of topic candidates before return
    `return` topic candidates - the generated collection of Noun based topics that have been extracted and constructed
    """
    if isinstance(body_of_text, unicode):
        body_of_text = unicodedata.normalize('NFKD', body_of_text).encode('ascii', 'ignore')
    processed = _info_extract_preprocess(body_of_text)   # preprocessed body for tagged words in sentence form
    return _get_NP_topics(processed)

def _parse_topics_not_nouns(*kargs):
    """
    `Author` Bob S.

    Method used for parsing topics that are not conjunctive noun words.
    Second to the NP form that is preferred use. Does not produce effective NNPs.
    However, only means to yield the non-nouns words of interest

    `kargs` - the params (in the form zero or more) raw bodies of text to be processed
    `yield` topic candidates - the generated collection of non-Noun topics that have been extracted and constructed
    """
    ret = []
    for body_of_text in kargs:
        processed = _info_extract_preprocess(body_of_text)   # preprocessed body for tagged words in sentence form
        ret.append(_get_non_NP_topics(processed))
    return ret

def is_structured(data):
    """
    `Author` Bob S.

    This method determines if the given python string, data, is structured data or not.
    Structured data is information in the format the development team has agreed on using as the format to be used when we not examining raw, unfiltered text.
    This format is JSON.

    `data` the literal string that is passed to be checked
    `return` True if the string can be leaded in JSON format, else False
    """
    try:
        json.loads(data)
    except:
        return False
    return True

def _info_extract_preprocess(document):
    """
    `Author` Bob S.

    This method is used to perform the reiterative process of preparing the given body of text to be parsed.
    First the sentences are tokenized using the default method of sent_tokenize(), next, the words are tokenized one by one.
    Finally those words are tagged by the default tagger of pos_tagger()

    `document` the string form body of text to be pre-processed
    `return` tagged - the tokenized, then tagged body of sentence delimited text.
    """
    sentences = nltk.sent_tokenize(document) #tokenize sentence into sentences
    tokenized = [nltk.word_tokenize(sent) for sent in sentences] # tokenize each sentencs in sentences into tokenized
    tagged = [nltk.pos_tag(sent) for sent in tokenized] # tag the sentences in tokenized
    return tagged

def _get_NP_topics(tagged):
    """
    `Author` Bob S.

    this method creates and returns a list of topic candidate instances form the specified pre-processes body of text
    Each subdivided unit in the tagged param is processed only once, bounding the first half of this method to O(n).
    Then for each unique word form the tagged text, its number of appearances is counted and all associated topics have their count incremented to reflect this measure.
    Finally the list is returned in one state to be returned to the get_topics method

    `tagged` the pre-processed body of text returned form the ie_preprocess() method
    `debug` optional argument for printing state of topic candidates before return
    """
    listing = []
    counts = defaultdict(int)
    depth = 0
    topic = None
    prev_topic = None
    before = []
    for chunked in nltk.ne_chunk_sents(tagged, binary=False):
        for word_tag in chunked:
            depth += 1
            if type(word_tag) == nltk.Tree:
                title = " ".join([title for title, pos in word_tag.leaves()]) # the key word to be used as the likely topic
                topic = Topic_Candidate(title, depth=depth, prefix=prev_topic, before=before, after=[])
                before = []
                listing.append(topic)
                counts[title] += 1
                if prev_topic is not None:
                    prev_topic.suffix = topic
                prev_topic = topic
            else:
                word, pos = word_tag
                counts[word] += 1
                before.append(word)
                if topic is not None:
                    topic.append_after(word)

    # Build Counts Values for titles (and words) to be applied to fields of topic
    for title, count in counts.iteritems():
        for topic in listing:
            if title == topic.title:
                topic.strength = count

    if DEBUG:
        _reconstruct(listing)

    return listing

def _get_non_NP_topics(tagged):
    """
    `Author` Bob S.

    This method is the only viable alternative to gathering stats on non-noun base words for topic making.
    Leverages the concept of grammar parsing (or using a commented out regex parser) to garner verb and adjective topics

    `tagged` - the pre-processed, sentence delimited, tokenized, tagged, body of text
    `return` labels, counts - the affiliated labels and count of appearances for likely topics
    """
    labels = defaultdict(set) # the dictionary of labels whose values are associated sets of topics
    counts =  defaultdict(int)  # the dictionary of topics whose value is the count of appearances in the entire body of text

    grammar = r"""
      NP: {<DT|JJ|NN.*>+}          # Chunk sequences of DT, JJ, NN
      PP: {<IN><NP>}               # Chunk prepositions followed by NP
      VP: {<VB.*><NP|PP|CLAUSE>+$} # Chunk verbs and their arguments
      CLAUSE: {<NP><VP>}           # Chunk NP, PP, VP
      """
    cp = nltk.RegexpParser(grammar)

    """
    An alternative to pre-def grammar features chunking and chinking rules.
    This method failed to provide an increase in accuracy but will remain for posterity.

    >>> chunk_rule = ChunkRule("<.*>+", "Chunk everything")
    >>> chink_rule = ChinkRule("<VB\.>", "Chink on verbs/prepositions")
    >>> split_rule = SplitRule("<NN><VB>", "<DT><NN>",
    >>> "Split successive determiner/noun pairs")
    >>> chunk_parser = RegexpChunkParser([chunk_rule, chink_rule, split_rule], chunk_label = 'VB')
    """

    for sentence in tagged:
        """
        line used in tandem with the alt chunker seen above

        >>> chunked = chunk_parser.parse(sentence)
        """
        chunked = cp.parse(sentence)
        for i in chunked:
            if type(i) != nltk.Tree and (i[1].startswith('V') or i[1].startswith('J')):
                labels[i[1]].add(i[0])
                counts[i[0]] += 1

    for label in labels.keys():
            for title in labels[label]:
                strength = counts[title]
                yield Topic_Candidate(title=title, strength=strength, label=label)

def _timer(function):
    """ easy wrapper class for determining runtime of wrapped method"""

    @wraps(function)
    def func_timer(*args, **kwargs):
        t0 = timeit.default_timer()
        result = function(*args, **kwargs)
        t1 = timeit.default_timer()
        diff = t1 - t0
        phrase = " Total time running '%s': %s seconds " %(red(function.func_name), green(str(diff)))
        print '\n{:*^150}\n'.format(phrase)
        return result, diff
    return func_timer

def _process_input(input):
    """
    used by main and debugger for testing purposes
    """

    def process_string(string):
        text = string.strip()
        return text

    def process_url(url):
        import urllib
        from bs4 import BeautifulSoup
        html = urllib.urlopen(url).read()
        text = BeautifulSoup(html, "lxml")
        text = text.find("div", {"class" : "article-text"})
        text = text.get_text()

        return unicodedata.normalize('NFKD', text).encode('ascii', 'ignore')

    def process_file(file):
        text = get_text(file)
        text = text.strip()
        return text

    def get_text(file):
        import re
        """Read text from a file, normalizing whitespace and stripping HTML markup."""
        text = open(file).read()
        text = re.sub(r'<.*?>', ' ', text)
        text = re.sub('\s+', ' ', text)
        return text

    if validators.url(input):
        return process_url(input)
    elif os.path.exists(input):
        return process_file(input)
    else:
        return process_string(input)

@_timer
def main():
    """----demo usage in context----"""

    link = 'http://www.foxnews.com/us/2017/02/10/marine-vet-speaks-out-about-viral-video-supporting-trump-travel-ban.html'
    body =_process_input(link)
    """----Use in practical development of NP parser (parser of choice)----"""
    extracted = {'summary': body, 'link': link}
    return get_unstructured_topic(extracted, keys=['summary'])
    # return _parse_topics_not_nouns(body)


"""Code to assign working path of nltk_data resource to local copy, if one exists else tell user to download"""
try:
    # nltk.data.find(os.path.join('tokenizers', 'punkt.zip'))
    pass
except LookupError as e:
    print "\tPlease choose the location of the nltk_data resource (see file dialogue)"
    from  Tkinter import Tk
    import Tkinter, Tkconstants, tkFileDialog
    root = Tk()
    directory = tkFileDialog.askdirectory()
    nltk.data.path.append(directory)

if DEBUG:
    print "Using path(s) to nltk resources:", nltk.data.path

if __name__ == '__main__':
    results = main()[0]
    if DEBUG:
        print 'results:', green(str(results[0]))
        print 'link:', green(results[1])
    sys.exit(0)


"""
Used only for investigation of lemmatization.
Remnants kept in case it can be found useful.

def lemmatize_investigate():
    body = _process_input('http://www.foxnews.com/politics/2017/02/08/white-house-fires-back-at-immigration-order-critics-with-list-terror-arrests.html')
    tokenized = nltk.word_tokenize(body)
    tagged = nltk.pos_tag(tokenized)
    gen = generate_frequency_by_pos(tagged=tagged, pos=('JJ', 'VB'))
    from nltk.stem import WordNetLemmatizer
    wordnet_lemmatizer = WordNetLemmatizer()
    for elem in gen:
        print elem[0],
        for title, strength in elem[1]:
            print title, wordnet_lemmatizer.lemmatize(title), ',',
        print
"""
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="rss2neo.Parser.DEBUG" class="name">var <span class="ident">DEBUG</span></p>
      
  
    <div class="desc"><p>This file stores the static methods to interpret topic candidates from zero or more bodies of text.
The work that accomplishes this is in the method parse_topics
Structured_topic returns the structured topic instances form the body of the text in the rss feed summary.
is_structured returns a true if input data is structured, else false.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="rss2neo.Parser.blue" class="name">var <span class="ident">blue</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="rss2neo.Parser.green" class="name">var <span class="ident">green</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="rss2neo.Parser.red" class="name">var <span class="ident">red</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="rss2neo.Parser.get_structured_topic">
    <p>def <span class="ident">get_structured_topic</span>(</p><p>extracted)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Author</code> Bob S.</p>
<p>used by external modules to gather the structured topics of the summary of the feed json
make_set is used to specify whether a set of unique topic candidate instances is formed from the result of the call to _strucutred_topic</p>
<p><code>extracted</code> the json object of the feed being examined
<code>return</code> the result of the structured topic investigation.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.get_structured_topic', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.get_structured_topic" class="source">
    <pre><code>def get_structured_topic(extracted):
    """
    `Author` Bob S.

    used by external modules to gather the structured topics of the summary of the feed json
    make_set is used to specify whether a set of unique topic candidate instances is formed from the result of the call to _strucutred_topic

    `extracted` the json object of the feed being examined
    `return` the result of the structured topic investigation.
    """
    body_of_text = extracted['summary']
    return _structured_topic(body_of_text)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="rss2neo.Parser.get_unstructured_topic">
    <p>def <span class="ident">get_unstructured_topic</span>(</p><p>extracted, keys=(&#39;id&#39;, &#39;title&#39;, &#39;summary&#39;), make_set=True)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Author</code> Bob S.</p>
<p>used by external modules to gather the unstructured topics of the summary of the feed json</p>
<p><code>extracted</code> the json object of the feed being examined
<code>keys</code> the optional list of args that are the keys of the associative dictionary extracted to have topics extracted
<code>make_set</code> optional argument for creating set of unique instances on return
<code>debug</code> optional argument for printing state of topic candidates before return
<code>return</code> the set of the unique topic candidate instances to be inserted by RssGrapher</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.get_unstructured_topic', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.get_unstructured_topic" class="source">
    <pre><code>def get_unstructured_topic(extracted, keys=('id', 'title', 'summary'), make_set=True):
    """
     `Author` Bob S.

    used by external modules to gather the unstructured topics of the summary of the feed json

    `extracted` the json object of the feed being examined
    `keys` the optional list of args that are the keys of the associative dictionary extracted to have topics extracted
    `make_set` optional argument for creating set of unique instances on return
    `debug` optional argument for printing state of topic candidates before return
    `return` the set of the unique topic candidate instances to be inserted by RssGrapher
    """
    ret = []
    for key in keys:
            ret.extend(_parse_topics(extracted[key]))
    return set(ret) if make_set else ret
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="rss2neo.Parser.is_structured">
    <p>def <span class="ident">is_structured</span>(</p><p>data)</p>
    </div>
    

    
  
    <div class="desc"><p><code>Author</code> Bob S.</p>
<p>This method determines if the given python string, data, is structured data or not.
Structured data is information in the format the development team has agreed on using as the format to be used when we not examining raw, unfiltered text.
This format is JSON.</p>
<p><code>data</code> the literal string that is passed to be checked
<code>return</code> True if the string can be leaded in JSON format, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.is_structured', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.is_structured" class="source">
    <pre><code>def is_structured(data):
    """
    `Author` Bob S.

    This method determines if the given python string, data, is structured data or not.
    Structured data is information in the format the development team has agreed on using as the format to be used when we not examining raw, unfiltered text.
    This format is JSON.

    `data` the literal string that is passed to be checked
    `return` True if the string can be leaded in JSON format, else False
    """
    try:
        json.loads(data)
    except:
        return False
    return True
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="rss2neo.Parser.main">
    <p>def <span class="ident">main</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>----demo usage in context----</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.main', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.main" class="source">
    <pre><code>@wraps(function)
def func_timer(*args, **kwargs):
    t0 = timeit.default_timer()
    result = function(*args, **kwargs)
    t1 = timeit.default_timer()
    diff = t1 - t0
    phrase = " Total time running '%s': %s seconds " %(red(function.func_name), green(str(diff)))
    print '\n{:*^150}\n'.format(phrase)
    return result, diff
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="rss2neo.Parser.Topic_Candidate" class="name">class <span class="ident">Topic_Candidate</span></p>
      
  
    <div class="desc"><p><code>Author</code>: Bill Clark
A class created by the Parser to represent a Topic object in the graph, in relation
to the given record. The metadata then, is strictly tied to the record used when
creating the candidate.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.Topic_Candidate', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.Topic_Candidate" class="source">
    <pre><code>class Topic_Candidate(object):
    """
    `Author`: Bill Clark
    A class created by the Parser to represent a Topic object in the graph, in relation
    to the given record. The metadata then, is strictly tied to the record used when
    creating the candidate.
    """

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return str(self.title)

    def __init__(self, title, strength=None, label=None, after=None, before=None, suffix=None, prefix=None, depth=None):
        self.title = title
        self.strength = strength
        self.label = label
        self.after = after
        self.before = before
        self.depth = depth
        self.suffix = suffix
        self.prefix = prefix

    def keywordify(self):
        return {'name': self.title, 'strength': self.strength}

    def update_node(self, node):
        node['strength'] = self.strength
        return node

    def __eq__(self, other):
        return self.title == other.title

    def __ne__(self, other):
        return self.title != other.title

    def __hash__(self):
        return hash(self.title)

    def append_after(self, word):
        self.after.append(word)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#rss2neo.Parser.Topic_Candidate">Topic_Candidate</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.after" class="name">var <span class="ident">after</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.before" class="name">var <span class="ident">before</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.depth" class="name">var <span class="ident">depth</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.label" class="name">var <span class="ident">label</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.prefix" class="name">var <span class="ident">prefix</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.strength" class="name">var <span class="ident">strength</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.suffix" class="name">var <span class="ident">suffix</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rss2neo.Parser.Topic_Candidate.title" class="name">var <span class="ident">title</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="rss2neo.Parser.Topic_Candidate.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, title, strength=None, label=None, after=None, before=None, suffix=None, prefix=None, depth=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.Topic_Candidate.__init__', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.Topic_Candidate.__init__" class="source">
    <pre><code>def __init__(self, title, strength=None, label=None, after=None, before=None, suffix=None, prefix=None, depth=None):
    self.title = title
    self.strength = strength
    self.label = label
    self.after = after
    self.before = before
    self.depth = depth
    self.suffix = suffix
    self.prefix = prefix
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rss2neo.Parser.Topic_Candidate.append_after">
    <p>def <span class="ident">append_after</span>(</p><p>self, word)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.Topic_Candidate.append_after', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.Topic_Candidate.append_after" class="source">
    <pre><code>def append_after(self, word):
    self.after.append(word)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rss2neo.Parser.Topic_Candidate.keywordify">
    <p>def <span class="ident">keywordify</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.Topic_Candidate.keywordify', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.Topic_Candidate.keywordify" class="source">
    <pre><code>def keywordify(self):
    return {'name': self.title, 'strength': self.strength}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rss2neo.Parser.Topic_Candidate.update_node">
    <p>def <span class="ident">update_node</span>(</p><p>self, node)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rss2neo.Parser.Topic_Candidate.update_node', this);">Show source &equiv;</a></p>
  <div id="source-rss2neo.Parser.Topic_Candidate.update_node" class="source">
    <pre><code>def update_node(self, node):
    node['strength'] = self.strength
    return node
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
